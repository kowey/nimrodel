
#uses Implode Hyphenate.

% firstname support - see also list of firstnames in words/firstname.dtr

nimrodel.firstname.FIRSTNAME-LOOKUP:
	<> == elf.TOP
	<lookup $$name> == <try male nimrodel.firstname.IS-FIRSTNAME-MALE:<$$name> $$name>
	
	<try male $$node $$name> == < IF:< $$node THEN case found $$node 
								  ELSE try female nimrodel.firstname.IS-FIRSTNAME-FEMALE:<$$name> .> $$name >
	<try female $$node> == < IF:< $$node THEN case found $$node ELSE case default .> >
	
	<case found $$node> == $$node
	<case default> == **fail**
.


nimrodel.firstname.FIRSTNAMEROOT:	
	<> == nimrodel.LEXROOT:<>
	
	<token type> == firstname
	<token gender> == unknown
	<lex type> == 'Person'
	<lex cat> == propn
	% nimrodel additions
	<lex forename> == <here token word>
	<lex number> == sing
.

% try various patterns that follow a firstname to build a lexical person phrase
nimrodel.firstname.TRYFIRSTNAME:	
	<> == elf.TOP
	<node $$n> == Local:<$$n>
	
	<node $$n lex> == <node $$n try phrase lex>
	
	<node $$n try phrase> == <node $$n <map nimrodel.context.NEXT:<2 token context .> .> >
	
	%<map son of> == try type 2 firstname
	<map de> == try type 1 placename 
	<map of> == try type 1 placename 
	%<map his brother> == case brother
	<map the> == try type 1 occupation
	<map le> == try type 1 occupation
	<map> == try type 0 surname
	
	<node $$n try type $$skip $$target> == <node $$n <map2 $$target <node $$n here nimrodel.context.SKIP:<$$skip token.> token next token type .> .> >
	
	<map2 firstname firstname> == case skip 3 lex
	<map2 firstname propnoun> == case skip 3 lex
	<map2 placename placename> == case skip 2 lex
	<map2 placename propnoun> == case skip 2 lex
	<map2 placename2 placename> == case skip 3 lex
	<map2 placename2 propnoun> == case skip 3 lex
	<map2 placename2> == case skip 1 lex
	<map2 surname surname> == try surname
	<map2 surname propnoun> == try surname
	<map2 surname 'Occupation'> == case skip 1 lex
	<map2 occupation 'Occupation'> == case skip 2 lex
	<map2 occupation> == case skip 2 lex
	<map2> == case default 
	
	<node $$n try surname> == <node $$n <map3 <node $$n here token next token next token stem .> .> >
	
	<map3 de> == try type 2 placename2
	<map3 of> == try type 2 placename2
	<map3> == case skip 1 lex
	
	<node $$n case skip $$m> == nimrodel.phraseutils.SKIP:< $$m 'nimrodel.firstname.FIRSTNAMEROOT'>
	<node $$n case skip $$m lex lex surname> == Implode:<Hyphenate:<' ' nimrodel.phraseutils.NEXT:< $$m 'nimrodel.firstname.FIRSTNAMEROOT' token token word .> .> .>
	<node $$n case brother> == nimrodel.phraseutils.SKIP:< 2 'nimrodel.firstname.FIRSTNAMEROOT' lex>
	<node $$n case default> == Local:<$$n>
.

% look for evidence that a word is a firstname before treating it as one
nimrodel.firstname.MAYBEFIRSTNAME:
	<> == nimrodel.firstname.TRYFIRSTNAME
.

nimrodel.firstname.FEMALEFIRSTNAMEROOT:
	<> == nimrodel.firstname.TRYFIRSTNAME:<node 'nimrodel.firstname.FIRSTNAMEROOT'>
	<token gender> == female
.


nimrodel.firstname.MALEFIRSTNAMEROOT:
	<> == nimrodel.firstname.TRYFIRSTNAME:<node 'nimrodel.firstname.FIRSTNAMEROOT'>
	<token gender> == male
.

% Abbreviations don't do smart name handling for now
nimrodel.firstname.ABBRFIRSTNAMEROOT:
	<> == nimrodel.LEXROOT
	<[ $$n ]> == nimrodel.firstname.FIRSTNAMEROOT:<>
	<[ $$n ] lex nextrole> == <here token nextn Add:<$$n 1 .> lex nextrole .>
	<[ $$n ] lex end-char> == <here token nextn Add:<$$n 1 .> lex end-char .>
.

nimrodel.firstname.ABBRFIRSTNAME:
	<[ > == nimrodel.firstname.ABBRFIRSTNAMEROOT:<[>
	<> == <[ 0 ]>
.

