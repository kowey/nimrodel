% outputting JSON annotations for people only
% vim: set noexpandtab:

#uses Gensym Length Implode Explode LocalPath Rest.
#vars $eq: '=' '=='.


app.JSON:
	<> == elf.TOP
	<sp> == ' '
	<tab> == '\t'
	<nl> == '\n'
	<json reset> == 
		Gensym:<reset 'T' 'R' 'E' 'A' 'N' '#'>	
	
	% ignore document title
	<json title> ==
	
	<json sentence> == <convert <select entity 'Person'
		<json sentence-next> .> .>
	<json sentence-next $documentString [ > ==
		<json clause $documentString <next> ] .>
		<json sentence-next $documentString <skip> .>
	<json sentence-next> ==	
	
	<json clause $documentString entity **endpoint** > ==
	<json clause $documentString> ==
	 	Debug:<writeline Implode:<app.DUMP:<pretty> .>.>
		Debug:<trace
			<tail <json clause2 $documentString > .>
		.>
	
	<json clause2 $documentString entity> == <json entity Gensym:<gensym 'T'.> $documentString>
	<json clause2 $documentString rel> == <json rel Gensym:<gensym 'R' .> $documentString>
	<json clause2 $documentString rel $f equals> == <json rel equals $documentString $f equals>
	<json clause2 $documentString attr> == <json attr Gensym:<gensym 'A' .> $documentString>
	<json clause2 $documentString property> == <json property $documentString>
	<json clause2> == <json error clause-error>
	
	<json entity $id $documentString> ==
		<json entity2 <json check> $id $documentString>
	<json entity2 ok $id $documentString $type $start-char $end-char> ==	
		Debug:<writeline '--- vvv entity' $id $type 'vvv ---' .>
		Debug:<writeline>
		Debug:<writeline '------- entity' $id $type '-------' .>
		Debug:<trace
		$id
		<json render-entity $documentString $id $type $start-char $end-char>
		.>
		Debug:<writeline '--- ^^^ entity' $id $type '^^^ ---' .>
		%<json annotation $id >
	<json entity2 skip $id> == $id
	<json entity2> == <json error> 
	
	<json check> == ok
	<json check **endpoint**> == skip
	<json check **fail**> == type-error
	<json check $any **fail**> == range-error
	<json check $any $any2 **fail**> == range-error

	<json error clause-error $documentString> == 
		'T1' <json note 'T1' error 'unknown clause: ' LocalPath:<>  .>
	<json error type-error $id $documentString $type $start-char $end-char> ==
		<json clause2 $documentString entity unknown $start-char $end-char error 'No type specified (type set to unknown)'  >
	<json error range-error $id $documentString $type $start-char $end-char> ==
		<json entity $id $documentString $type 0 0 error 'Range error: ' $start-char ' ' $end-char '(set to 0)'  >

	<json rel $id $documentString $focus $type [ > == 
		Debug:<writeline '--- vvv rel ' $id $type 'vvv ---' .>
		Debug:<trace
		<json rel2 $id $documentString $focus $type <json clause2 $documentString <next> ] .> ] <skip> .>
		.>
		Debug:<writeline '--- ^^^ rel ' $id $type '^^^ ---' .>

	<json rel2 $id $documentString $focus is_widow_of $arg1> ==
		%<rotate
		<json focus $focus $arg1 			% target id for clause
			<next>	]		% annotation for first operand
			<json rel3 $id $documentString is_widow_of $arg1 <skip> .>
		.>
		%.>
	<json rel2> == <json rel2-generic>
	<json rel2-generic $id $documentString $focus $type $arg1> ==
		<json focus $focus $arg1 			% target id for clause
			<next>	]		% annotation for first operand
			<json rel3 $id $documentString $type $arg1 <skip> .>
		.>
	<json rel3 equals> == <json rel6 equals>
	<json rel3> == <json rel4>
	<json rel4 $id $documentString $type $arg1 [ > ==
		<json rel5 $id $type $arg1 <json clause2 $documentString> .>
	<json rel5 $id $type $arg1 $arg2> ==
		$arg2
		LocalPath:<> 	% annotation for second operand
		%<json render-rel $id $type $arg1 $arg2>
	% handle equals relations by rewriting second id arg as first
	<json rel6 equals $documentString $type $arg1 [ > ==
		<json rewrite-id $arg1 <json clause2 $documentString> .>
	
	% prefix our output with the id of the focused line
	<json focus 1 $arg1> == $arg1 <next> <json focus3 <skip> .>
	<json focus 2 $arg1> == <json focus2 <skip> .> <next> <json focus3 <skip> .>
	<json focus2 $arg2 > == $arg2
	<json focus3 $arg2 > == LocalPath:<>
		
	<json rewrite-id $$arg1 $$arg2> ==
		$$arg1
		Rest:< <json rewrite-id2 $$arg1 $$arg2 '\n' > .>
	<json rewrite-id2 $$arg1 $$arg2 '\n' $$arg2> == <json rewrite-id2 $$arg1 $$arg2 <skipline> .>
	<json rewrite-id2 $$arg1 $$arg2 $$arg2> == $$arg1 <json rewrite-id3 $$arg1 $$arg2>
	<json rewrite-id2> == <json rewrite-id3>
	<json rewrite-id3 $$arg1 $$arg2 $$any> == $$any <json rewrite-id2 $$arg1 $$arg2>
	<json rewrite-id3> ==
		
	<json attr $id $documentString $attr $val [ > ==
		<json attr2 $id $documentString $attr $val <json clause2 $documentString> .>
	<json attr2 $id $documentString $attr $val $arg> ==
		$arg
		LocalPath:<>
		<json render-attr $id $arg $attr $val>
		
	<json property $documentString $attr $val [ > ==
		<json property2 $documentString $attr $val <json clause2 $documentString> .>
	<json property2 $documentString $attr $val $arg> ==
		$arg
		LocalPath:<>
		<json prop $arg $attr '=' $val .>	
		
	% slightly modify entity by adding an origOccurence attribute
	<json render-entity $documentString $id $type $start-char $end-char> == 
		$id
		[ entity $type $start-char $end-char
			origOccurence '='
			<text-for-span $documentString $type $start-char $end-char .>
			<next>% take till closing bracket (ignores multiples)
		] <nl .>
	<json render-trans> ==
	
	<json render-rel $id $type $arg1 $arg2> ==
		$id <tab .>
		$type <sp .>
		'Arg1:' $arg1 <sp .>
		'Arg2:' $arg2 <nl .>
		
	<json render-attr $id $arg $attr $val> == 
		$id <tab .>
		$attr <sp .> 
		$arg <sp .> 
		$val <nl .>
		
		
	<json annotation $id ']'> ==
	<json annotation $id $f $eq $v> == <json map-feature $f $v .> <json annotation $id>
	<json annotation $id> == <json note $id>

	% rename, delete, or pass through features
	<json map-feature gender> == 'gender-TO-DELETE' LocalPath:<>
	<json map-feature> == LocalPath:<>
	
	<json notes $id [ > == <json notes2 $id>
	<json notes $id> == 
	<json notes2 $id> == <json note $id> <json notes $id <skip> .>
	
	<json note> == <json note1 'Note'>
	<json note $id error> == <json errnote $id>
	<json errnote> == <json note1 'ERROR'>
	<json prop> == <json note1 'Property'>
	
	<json note1 $label $id ] > ==
	<json note1> == <json note2>
	
	<json note2 $label $id $any> ==
		Gensym:<gensym '#'> <tab>
		$label <sp>
		$id <tab>
		<json note3 $any>
		<nl>
	<json note2> ==
	<json note3 ']'> ==
	<json note3> == <json note4>
	<json note4 $any> == $any <sp> <json note3>
	<json note4> ==

	<text-for-span $documentString $type $start-char $end-char> ==
		openNLP.GetSpanStrings:<$documentString
			openNLP.NewSpan:<$type $start-char $end-char .> .>

	% --------------------------------------------------
	% relation rotation
	% --------------------------------------------------

	% given
	%
	% handle arg1 line1
	% 	 arg2 line2
	<rotate> == <rotate2 'origOccurence' 'injected-FIXME'>
	<rotate2 $attr-src $attr-tgt $arg $arg> ==
		$arg <promote-left $attr-src $attr-tgt $arg>
	<rotate2 $attr-src $attr-tgt $arg> ==
		$arg <promote-right $attr-src $attr-tgt $arg>

	% rotate the left argument of a relation to the top and
	% inject some identifying feature from the right argument
	<promote-left $attr-src $attr-tgt> ==
		<add-feature $attr-tgt
			<get-attr $attr-src <skipline> .>
			<takeline>
		.>
		<skipline>
	% mirror of promote-left
	<promote-right $attr-src $attr-tgt> ==
		<add-feature $attr-tgt
			<get-attr $attr-src <takeline> .>
			<tail <skipline> .>
		.>
		<takeline> <nl>

	% --------------------------------------------------
	% manipulating nimrodel literals
	% --------------------------------------------------

	% nimrodel attribute value pair
	<feature $key $val> == $key '=' $val

	<add-feature $key $value $handle [ $x1 $x2 $x3 $x4> ==
		$handle [ $x1 $x2 $x3 $x4 <feature $key $value .> LocalPath:<>
	<add-feature $key $value [ $x1 $x2 $x3 $x4> ==
		[ $x1 $x2 $x3 $x4 <feature $key $value .> LocalPath:<>


	% take the handle associated with a fragmentary output
	<get-handle $any> == $any

	% take the value of an attribute
	<get-attr $key $key $eq $value> == $value
	<get-attr $key $any> == <get-attr $key>
	<get-attr> ==

	% combine two nimrodel internal semantic literals into one
	% assume they share the same prefix (taken from the first)
	% (this is really just dumb token rewriting)
	<append> == [ <append-helper> ]
	<append-helper [ $$x1 $$x2 $$x3 $$x4> ==
		$$x1 $$x2 $$x3 $$x4
		<next>
		<append-last <skip> .>
	<append-last [ $$x1 $$x2 $$x3 $$x4 > ==
		<next>

	<skipb [> == <skip>	
		
	<skip ] > == LocalPath:<>
	<skip [ > == <skip <skip> .>
	<skip> == <skip2>
	<skip2 $any> == <skip>
	<skip2> ==

	<nextb [ > == <next>
	
	<next ] > == 
	<next [ > == [ <next> ] <next <skip> .>
	<next> == <next2>
	<next2 $any> == $any <next>
	<next2> ==
	
	<tail $any> == LocalPath:<>
	<tail> ==

	% --------------------------------------------------
	% manipulating named lines
	% a named line has the form
	%
	% prefix <payload> <nl>
	% --------------------------------------------------

	% named takeline $name:
	% given a block of named lines, select the line prefixed with $name
	<named takeline $arg $arg> == $arg <takeline>
	<named takeline> == <named takeline2>
	<named takeline2 $arg $any> == <named takeline $arg
		<tail <skipline> .>
	.>
	<named takeline2> ==

	% named add-feature $named $key $val
	%
	% add the feature to the line prefixed with $named
	% pass the rest of lines through
	<named add-feature $arg $key $value $any> ==
		<named add-feature-one $arg $key $value $any>
		<named add-feature $arg $key $value <tail <skipline> .> .>
	<named add-feature> ==
	% helper: what to do when we actually hit the line
	<named add-feature-one $arg $key $value $arg> ==
		$arg <add-feature $key $value <takeline> .> <nl>
	<named add-feature-one> == <named add-feature-one2>
	<named add-feature-one2 $arg $key $value $any> ==
		$any <takeline> <nl> % pass through

	<takeline '\n'> ==
	<takeline> == <takeline2>
	<takeline2 $any> == $any <takeline>
	<takeline2> ==
	
	<skipline '\n'> == '\n' LocalPath:<>
	<skipline> == <skipline2>
	<skipline2 $$any> == <skipline>
	<skipline2> ==
	
	% --------------------------------------------------
	% filtering
	% --------------------------------------------------

	% pick out only literals of the given type
	<select $supertype $type [> ==
		<select-one $supertype $type [ <next> ] .>
		<select $supertype $type <skip> .>
	<select> ==
		
	<select-one $supertype $type [ $supertype $type> ==
		[ $supertype $type LocalPath:<>
	<select-one $supertype $type> ==


	% --------------------------------------------------
	% nimrodel to json conversion
	% --------------------------------------------------

	% convert flat list of nimrodel internal semantic literals to
	% list of json records; we ignore types and assume that each
	% feature in each literal is meant to serve as a dictionary key
	<convert> ==
		Debug:<writeline 'CONVERT' >
		<mk-json long-list <convert-helper> .>
	<convert-helper [> ==
		Debug:<writeline 'CONVERT-HELPER' [>
		<convert-one <next> ] .>
		<convert-helper <skip> .>
	<convert-helper> ==	
	<convert-one entity $any $start-char $end-char> ==
		<mk-json record json.UNIQUE:<unique <strip-eq> .> .>

	% from [ f1 = v2 f2 =v3 ] to just [ f1 v2 f2 v3 ]
	<strip-eq $$f $eq $$v> == $$f $$v <strip-eq>
	<strip-eq ]> ==
	<strip-eq> == <strip-eq2>
	<strip-eq2 $any> ==
		'ERROR: was expecting only sequence of f = v, but got'
		$any LocalPath:<>
	<strip-eq2> ==

	<mk-json> == json.STRUCT:<>
.
