% outputting JSON annotations for people only
% vim: set noexpandtab:

#uses Gensym Length Implode Explode LocalPath Rest.
#vars $eq: '=' '=='.

% ---------------------------------------------------------------------
% glossary
%
% nimrodel literal: tokens that correspond to a single fragment
%     of nimodel's internal semantic representation
%
%     [ supertype type start-char end-char etc... ]
%
%     Syntactically, the nimrodel internal semantic representation
%     is nested/recursive; although it is flat in essence.
%
%     Literals for entities are completely flat, and we will try
%     to refer to these as entity literals
%
% named line: a line of the form <prefix> <entity literal> <nl>
%     the payload is some arbitrary token sequence
%     (here an entity literal)
%
%     the prefix serves as an identifier for the literal
%
% tagged bundle: a handle followed by a list of named lines.
%      the handle is the prefix of one of the named lines;
%
%      It says in essence that while the bundle represents
%      several entities, one of them is of particular interest
%      to us
%
% distinguished entity: in a tagged bundle, the entity that
%      is being pointed to by the bundle handle
% ---------------------------------------------------------------------


app.JSON:
	<> == elf.TOP
	<sp> == ' '
	<tab> == '\t'
	<nl> == '\n'
	<json reset> == 
		Gensym:<reset 'T' 'R' 'E' 'A' 'N' '#'>	
	
	% ignore document title
	<json title> ==
	
	<json sentence> == <convert
		<select entity 'Person' <named strip
			Debug:<tracemsg '----v--sentence--v----\n'
			<json sentence-next>
			.>
		.> .> .>
	<json sentence-next $documentString [ > ==
		<json clause $documentString <next> ] .>
		<json sentence-next $documentString <skip> .>
	<json sentence-next> ==	
	
	<json clause $documentString entity **endpoint** > ==
	<json clause $documentString> ==
	 	Debug:<writeline Implode:<app.DUMP:<pretty> .>.>
		Debug:<trace
			<tail <json clause2 $documentString > .>
		.>
	
	<json clause2 $documentString entity> == <json entity Gensym:<gensym 'T'.> $documentString>
	<json clause2 $documentString rel> == <json rel Gensym:<gensym 'R' .> $documentString>
	<json clause2 $documentString rel $f equals> == <json rel equals $documentString $f equals>
	<json clause2 $documentString attr> == <json attr Gensym:<gensym 'A' .> $documentString>
	<json clause2 $documentString property> == <json property $documentString>
	<json clause2> == <json error clause-error>
	
	<json entity $id $documentString> ==
		<json entity2 <json check> $id $documentString>
	<json entity2 ok $id $documentString $type $start-char $end-char> ==	
		$id
		<json render-entity $documentString $id $type $start-char $end-char>
	<json entity2 skip $id> == $id
	<json entity2> == <json error> 
	
	<json check> == ok
	<json check **endpoint**> == skip
	<json check **fail**> == type-error
	<json check $any **fail**> == range-error
	<json check $any $any2 **fail**> == range-error

	<json error clause-error $documentString> == 
		'T1' <json note 'T1' error 'unknown clause: ' LocalPath:<>  .>
	<json error type-error $id $documentString $type $start-char $end-char> ==
		<json clause2 $documentString entity unknown $start-char $end-char error 'No type specified (type set to unknown)'  >
	<json error range-error $id $documentString $type $start-char $end-char> ==
		<json entity $id $documentString $type 0 0 error 'Range error: ' $start-char ' ' $end-char '(set to 0)'  >

	% ---------------------------------------------------------------------
	% Relations are tricky.
	%
	% The input is more or less a (recursive) nimrodel literal, although
	% abstracting from the detail, we can think of the input as being
	% fundementally `Rel(focus, side1, side2)`, where focus is either
	% 1 or % 2 referring to which side the relation is about.
	%
	% It may be useful to keep a few key points in mind:
	%
	% 1. in essence, a relation literal actually refers to a single
	%    entity, ie. the one represented by side1 or side2
	%
	% 2. in form, a relation literal is a nested representation for
	%    several entities, so we don't just emit one entity but a
	%    whole list of them as output
	%
	% 3. indeed the same is true for side1 and side2; while they
	%    are in essence referring to a single entity, they return
	%    tagged bundles (see glossary) along the way which we want
	%    to merge and emit
	%
	% We manage this by using a tagged bundle representation for
	% our output: ie. a list of named lines (multiple entities),
	% along with a handle saying which one we are referring to.
	% This allows us to manipulate the individual entities referred
	% to by side1 or side2 (we scurry up and down the named lines
	% looking for the entity referred to by the bundle handle).
	% This may make a bit more sense after some (hopefully now less)
	% squinting at the code.
	% ---------------------------------------------------------------------


	<json rel $id $documentString $focus $type [ > == 
		Debug:<writeline '--- vvv rel ' $id $type 'vvv ---' .>
		Debug:<trace
		<json rel-inner $id $documentString $focus $type
		        <json clause2 $documentString <next> ] .> ] <skip> .>
		.>
		Debug:<writeline '--- ^^^ rel ' $id $type '^^^ ---' .>

	<json rel-inner $id $documentString $focus equals $arg1> ==
                <json rel-equals $id $documentString $focus equals $arg1>
	<json rel-inner $id $documentString $focus is_widow_of $arg1> ==
		<json rel-inject 'lateHusband' $id $documentString $focus is_widow_of $arg1>
	<json rel-inner> == <json rel-generic>

	% json rel-generic: relation literal (ish) -> tagged bundle
	% render both sides and do nothing else
	<json rel-generic $id $documentString $focus $type $arg1> ==
		<json focus $focus $arg1 			% target id for clause
			<next>	]		% annotation for first operand
			<json rel-next $id $documentString $type $arg1 <skip> .>
		.>
	% json rel-equals: relation literal (ish) -> tagged bundle
	% merge the distinguished entity in the two sides
	% (other lines are left intact)
	<json rel-equals $id $documentString $focus $type $arg1> ==
		<json merge-id $arg1
			<json clause2 $documentString <tail <skip> .> .>
			<next>
		.>
	% json rel-inject: string -> relation literal (ish) -> tagged bundle
	% in addition to the usual, inject the origOccurence feature
	% into the focused argument as the target feature name
	<json rel-inject $attr-tgt $id $documentString $focus $type $arg1> ==
		<named inject 'origOccurence' $attr-tgt
		<json endpoints $focus $arg1 			% target id for clause
			<next>	]		% annotation for first operand
			<json rel-next $id $documentString $type $arg1 <skip> .>
		.>
		.>

	% json rel-next: produce annotation for second operand
	<json rel-next $id $documentString $type $arg1 [ > ==
		<json rel-next2 $id $type $arg1 <json clause2 $documentString> .>
	<json rel-next2 $id $type $arg1 $arg2> ==
		$arg2
		LocalPath:<> 	% annotation for second operand

	% json focus: focus -> ??? -> tagged bundle
	% (here it's not a list of lines per se that's the input, but
	% something close to it)
	% prefix our output with the id of the focused line
	<json focus 1 $arg1> == $arg1 <next> <json focus3 <skip> .>
	<json focus 2 $arg1> == <json focus2 <skip> .> <next> <json focus3 <skip> .>
	<json focus2 $arg2 > == $arg2
	<json focus3 $arg2 > == LocalPath:<>

	% json endpoints: focus -> ??? -> tagged bundle
	% almost identical to json focus, only we prefix with
	% the less prefered one, and then the handle
	%
	% (so json focus should be a suffix of this)
	<json endpoints 1 $arg1> ==
		<get-handle <skip> .> $arg1
		<next> <json endpoints3 <skip> .>
	<json endpoints 2 $arg1> ==
		$arg1 <get-handle <skip> .>
		<next> <json endpoints3 <skip> .>
	<json endpoints2 $arg2 > == $arg2
	<json endpoints3 $arg2 > == LocalPath:<>


	% rewrite the block replacing both the $$arg1 and the $$arg2 line with
	% a merged equivalent
	<json merge-id $$arg1 $$arg2> ==
		$$arg1
		$$arg1 nimrodel.INNER:<merge
			<tail <named takeline $$arg1> .>
			<tail <named takeline $$arg2> .> .> <nl>
		Rest:< <json merge-id2 $$arg1 $$arg2 '\n' > .>
	<json merge-id2 $$arg1 $$arg2 '\n' $$arg1> ==
		<json merge-id2 $$arg1 $$arg2 <skipline> .>
	<json merge-id2 $$arg1 $$arg2 '\n' $$arg2> ==
		<json merge-id2 $$arg1 $$arg2 <skipline> .>
	% this is just straight token rewriting s/$$arg2/$$arg1/
	<json merge-id2 $$arg1 $$arg2 $$arg2> ==
		$$arg1 <json merge-id3 $$arg1 $$arg2>
	<json merge-id2> == <json merge-id3>
	<json merge-id3 $$arg1 $$arg2 $$any> ==
		$$any <json merge-id2 $$arg1 $$arg2>
	<json merge-id3> ==

	% --------------------------------------------------
	% render helpers
	% --------------------------------------------------

	<json attr $id $documentString $attr $val [ > ==
		<json attr2 $id $documentString $attr $val <json clause2 $documentString> .>
	<json attr2 $id $documentString $attr $val $arg> ==
		$arg
		LocalPath:<>
		<json render-attr $id $arg $attr $val>
		
	<json property $documentString $attr $val [ > ==
		<json property2 $documentString $attr $val <json clause2 $documentString> .>
	<json property2 $documentString $attr $val $arg> ==
		$arg
		LocalPath:<>
		<json prop $arg $attr '=' $val .>	
		
	% slightly modify entity by adding an origOccurence attribute
	<json render-entity $documentString $id $type $start-char $end-char> == 
		$id
		[ entity $type $start-char $end-char
			origOccurence '='
			<text-for-span $documentString $type $start-char $end-char .>
			<next>% take till closing bracket (ignores multiples)
		] <nl .>
	<json render-trans> ==
	
	<json render-attr $id $arg $attr $val> == 
		$id <tab .>
		$attr <sp .> 
		$arg <sp .> 
		$val <nl .>
		
		
	<json annotation $id ']'> ==
	<json annotation $id $f $eq $v> == <json map-feature $f $v .> <json annotation $id>
	<json annotation $id> == <json note $id>

	% rename, delete, or pass through features
	<json map-feature gender> == 'gender-TO-DELETE' LocalPath:<>
	<json map-feature> == LocalPath:<>
	
	<json notes $id [ > == <json notes2 $id>
	<json notes $id> == 
	<json notes2 $id> == <json note $id> <json notes $id <skip> .>
	
	<json note> == <json note1 'Note'>
	<json note $id error> == <json errnote $id>
	<json errnote> == <json note1 'ERROR'>
	<json prop> == <json note1 'Property'>
	
	<json note1 $label $id ] > ==
	<json note1> == <json note2>
	
	<json note2 $label $id $any> ==
		Gensym:<gensym '#'> <tab>
		$label <sp>
		$id <tab>
		<json note3 $any>
		<nl>
	<json note2> ==
	<json note3 ']'> ==
	<json note3> == <json note4>
	<json note4 $any> == $any <sp> <json note3>
	<json note4> ==

	<text-for-span $documentString $type $start-char $end-char> ==
		openNLP.GetSpanStrings:<$documentString
			openNLP.NewSpan:<$type $start-char $end-char .> .>

	% --------------------------------------------------
	% relation rotation
	% --------------------------------------------------

	% given
	%
	% attr-src attr-tgt
	% arg-src arg-tgt [named line]
	%
	% lift a feature from the arg-src line and inject it into
	% arg-tgt line
	<named inject $attr-src $attr-tgt $arg-src $arg-tgt> ==
		$arg-tgt
		<named add-feature $arg-tgt
			$attr-tgt
			<get-attr $attr-src <named takeline $arg-src> .>>


	% --------------------------------------------------
	% manipulating nimrodel literals
	% --------------------------------------------------

	% nimrodel attribute value pair
	<feature $key $val> == $key '=' $val

	<add-feature $key $value $handle [ $x1 $x2 $x3 $x4> ==
		$handle [ $x1 $x2 $x3 $x4 <feature $key $value .> LocalPath:<>
	<add-feature $key $value [ $x1 $x2 $x3 $x4> ==
		[ $x1 $x2 $x3 $x4 <feature $key $value .> LocalPath:<>


	% take the handle associated with a fragmentary output
	<get-handle $any> == $any

	% take the value of an attribute
	<get-attr $key $key $eq $value> == $value
	<get-attr $key $any> == <get-attr $key>
	<get-attr> ==

	<skipb [> == <skip>	
		
	<skip ] > == LocalPath:<>
	<skip [ > == <skip <skip> .>
	<skip> == <skip2>
	<skip2 $any> == <skip>
	<skip2> ==

	<nextb [ > == <next>
	
	<next ] > == 
	<next [ > == [ <next> ] <next <skip> .>
	<next> == <next2>
	<next2 $any> == $any <next>
	<next2> ==
	
	<tail $any> == LocalPath:<>
	<tail> ==


	% --------------------------------------------------
	% manipulating named lines
	% a named line has the form
	%
	% prefix <payload> <nl>
	% --------------------------------------------------

	% named takeline $name:
	% given a block of named lines, select the line prefixed with $name
	<named takeline $arg $arg> == $arg <takeline>
	<named takeline> == <named takeline2>
	<named takeline2 $arg $any> == <named takeline $arg
		<tail <skipline> .>
	.>
	<named takeline2> ==

	% named add-feature $named $key $val
	%
	% add the feature to the line prefixed with $named
	% pass the rest of lines through
	<named add-feature $arg $key $value $any> ==
		<named add-feature-one $arg $key $value $any>
		<named add-feature $arg $key $value <tail <skipline> .> .>
	<named add-feature> ==
	% helper: what to do when we actually hit the line
	<named add-feature-one $arg $key $value $arg> ==
		$arg <add-feature $key $value <takeline> .> <nl>
	<named add-feature-one> == <named add-feature-one2>
	<named add-feature-one2 $arg $key $value $any> ==
		$any <takeline> <nl> % pass through

	% named strip : [named literal] -> [literal]
	<named strip $id [> ==
		[ <takeline> <named strip <tail <skipline> .> .>
	<named strip> ==

	<takeline '\n'> ==
	<takeline> == <takeline2>
	<takeline2 $any> == $any <takeline>
	<takeline2> ==
	
	<skipline '\n'> == '\n' LocalPath:<>
	<skipline> == <skipline2>
	<skipline2 $$any> == <skipline>
	<skipline2> ==
	
	% --------------------------------------------------
	% filtering
	% --------------------------------------------------

	% pick out only literals of the given type
	<select $supertype $type [> ==
		<select-one $supertype $type [ <next> ] .>
		<select $supertype $type <skip> .>
	<select> ==
		
	<select-one $supertype $type [ $supertype $type> ==
		[ $supertype $type LocalPath:<>
	<select-one $supertype $type> ==


	% --------------------------------------------------
	% nimrodel to json conversion
	% --------------------------------------------------

	% convert flat list of nimrodel internal semantic literals to
	% list of json records; we ignore types and assume that each
	% feature in each literal is meant to serve as a dictionary key
	<convert> ==
		Debug:<writeline 'CONVERT' >
		<mk-json long-list <convert-helper> .>
	<convert-helper [> ==
		Debug:<writeline 'CONVERT-HELPER' [>
		<convert-one <next> ] .>
		<convert-helper <skip> .>
	<convert-helper> ==	
	<convert-one entity $any $start-char $end-char> ==
		<mk-json record json.UNIQUE:<unique <strip-eq> .> .>

	% from [ f1 = v2 f2 =v3 ] to just [ f1 v2 f2 v3 ]
	<strip-eq $$f $eq $$v> == $$f $$v <strip-eq>
	<strip-eq ]> ==
	<strip-eq> == <strip-eq2>
	<strip-eq2 $any> ==
		'ERROR: was expecting only sequence of f = v, but got'
		$any LocalPath:<>
	<strip-eq2> ==

	<mk-json> == json.STRUCT:<>
.

% tools for manipulating the nimrodel internal semantics
nimrodel.INNER:

	% merge: literal -> literal -> literal
	%
	% given two adjacent literals, return a single merged literal
	% by appending any features not found in the first (from the
	% second literal). Note that duplicate features are ignored
	<merge> == <keep-one <append> .>

	% keep-one : literal -> literal
	% retain the first instance of each attribute
	% ignore any subsequent instances
	<keep-one> == <tweak-features keep-one-inner>
	<keep-one-inner $$key $eq $$val> ==
		$$key $eq $$val
		<keep-one-inner <delete-key $$key> .>
	<keep-one-inner> ==

	% delete-key : features -> features
	<delete-key $$key $$key $eq $$val> == <delete-key $$key>
	<delete-key> == <delete-key2>
	<delete-key2 $$key $$any $eq $$val> ==
		$$any $eq $$val <delete-key $$key>
	<delete-key2> ==

	% tweak-features : (features -> features) -> (literal -> literal)
	% apply $$fn on just the key = val pairs, keeping
	% the rest of the literal the same
	<tweak-features $$fn [ $x1 $x2 $x3 $x4> ==
		[ $x1 $x2 $x3 $x4
		<$$fn <init> .>
		]

	% append : literal -> literal -> literal
	% combine two nimrodel internal semantic literals into one
	% assume they share the same prefix (taken from the first)
	% (this is really just dumb token rewriting)
	<append> == [ <append-helper> ]
	<append-helper [ $$x1 $$x2 $$x3 $$x4> ==
		$$x1 $$x2 $$x3 $$x4
		<next>
		<append-last <skip> .>
	<append-last [ $$x1 $$x2 $$x3 $$x4 > == <next>

	% init : stream -> stream
	% init on empty stream also returns empty stream
	<init $$any1 $$any2> == $$any1 <init $$any2>
	<init> == <init2>
	<init2 $$any> ==
	<init2> ==

	% skip : stream -> stream
	<skip ] > == LocalPath:<>
	<skip [ > == <skip <skip> .>
	<skip> == <skip2>
	<skip2 $any> == <skip>
	<skip2> ==

	% next : stream -> stream
	<next ] > ==
	<next [ > == [ <next> ] <next <skip> .>
	<next> == <next2>
	<next2 $any> == $any <next>
	<next2> ==
.
