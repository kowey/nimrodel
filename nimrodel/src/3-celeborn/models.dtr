%   File:       models.dtr
%   Purpose:    nimrodel lexical models
%   Author:     Roger Evans
%   Version:    1.0
%   Date:       06/02/2013
%
%   (c) Copyright 2013, University of Brighton
%   MODELS

#vars $model:
	token pos params
	lex 
	$phrase subcat person
	sem
.


#hide nimrodel.LEX-TOP.
nimrodel.LEX-TOP:
	<> == elf.STRING-TOP
	
	<token prevrole> == <prevrole>
	<token nextrole> == <nextrole>
	<token prev> == Local:<QueryNode <here token prevrole.> end elf.LANG:<GlobalPath.>>
    <token next> == Local:<QueryNode <here token nextrole.> start elf.LANG:<GlobalPath.>>
	% avoiding long chains of prev/next links - but only works if never overridden locally
	<token prevn $n> == Local:<QueryNode <here token prevrole $n.> end elf.LANG:<GlobalPath.>>
    <token nextn $n> == Local:<QueryNode <here token nextrole $n.> start elf.LANG:<GlobalPath.>>
	
	<token> == **fail**
	<token type> == unknown
	<token word> == <self param word>
	<token form> == <self param form>
	<token pos> == <self param pos>
	<token stem> == <self param stem>
	<token mor form> == <self param mform>
	<token mor tense> == <self param mtense>
	<token mor num> == <self param mnum>
	<token mor per> == <self param mper>
	<token casetype> == <self param casetype>
	<token soundex> == <self param soundex>
	<token start-char> == <self param pre-absStart>
	<token end-char> == <self param pre-absEnd>
	<token index> == elf.SELF
	<token output> == <render entity token>
	<token id> == <here token stem>
	<token context> == token stem
	
	<params> == <here token>
	<params type> == <here token pos>
	<params mform> == <here token mor form>
	<params mtense> == <here token mor tense>
	<params mper> == <here token mor per>
	<params mnum> == <here token mor num>
	<params output> == <render entity params>
		
	<pos> == <here token>
	<pos type> == <here token pos>
	<pos output> == <render entity pos>
		
	<lex> == <here token>
	<lex parent> == token
	<lex prev> == Local:<QueryNode <here lex prevrole.> lexend elf.LANG:<GlobalPath.>>
    <lex next> == Local:<QueryNode <here lex nextrole.> lexstart elf.LANG:<GlobalPath.>>
	<port lexstart> == <here port start>
	<port lexend> == <here port end>
	
	<lex cat> == <here token pos>
	<lex output> == <render entity lex>
	
	<$phrase> == <here lex>
	<$phrase parent> == lex
	<$phrase prev> == Local:<QueryNode <here $phrase prevrole.> phraseend elf.LANG:<GlobalPath.>>
    <$phrase next> == Local:<QueryNode <here $phrase nextrole.> phrasestart elf.LANG:<GlobalPath.>>
	<port phrasestart> == <here port lexstart>
	<port phraseend> == <here port lexend>
	
	<$typedphrase cat> == **fail**
	<$phrase rel> == unknown
	<$phrase conjrel> == unknown
	<$phrase output> == <render entity $phrase>
	
	<subcat> == <here phrase>
	<subcat type> == <here phrase cat>
	<subcat output> == <render entity subcat>
	
	<person> == <here phrase>
	<person type> == <person-check <here phrase type .> >
	
	<person-check 'Person'> == 'Person'
	<person-check> == unknown
	
	<sem> == <here phrase>
	<sem parent> == phrase
	<sem prev> == Local:<QueryNode <here sem prevrole.> semend elf.LANG:<GlobalPath.>>
    <sem next> == Local:<QueryNode <here sem nextrole.> semstart elf.LANG:<GlobalPath.>>
	<port semstart> == <here port phrasestart>
	<port semend> == <here port phraseend>
	
	<sem output> == <render entity sem>
	<sem status> == complete
	<sem binding> == unknown
		
	<process $model> == <here all $model process1 $model>
	<process1 $model> == <process2 $model <here $model type.> .>
	<process2 sem $type> == IF:<ONEOF:<$type unknown unbound.> THEN ELSE <here sem output $type> .>
	<process2> == <process3>
	<process3 $model $type> == IFEQ:<$type unknown THEN ELSE <here $model output $type> .>
	
	<render> == nimrodel.RENDER
.
	
#hide nimrodel.RENDER.
nimrodel.RENDER:
	<> == elf.STRING-TOP
	
	% <render entity $model ($type) >
	% start char and end char and per-model attributes and annotations added automatically
	<render entity $model> == <render entity2 $model <here $model type.> .>
	<render entity $model $type > == <render entity2 $model $type .>
	<render entity2 $model $type> ==
		[
			entity
			$type	
			<here $model start-char>
			<here $model end-char>	
			<process-attribute $model norm>		% always have a norm attribute
			<process-attributes $model $type>
			<process-annotation $model>
		]
	
	
	% <render rel $model ($type $rel) [ ... ]>
	% apply rel to current entity as Arg1 and specified entity as Arg2
	<render rel $model [ > == <render rel2 $model <here $model type.> <here $model rel.> [ >
	<render rel> == <render rel2>
	<render rel2 $model $type $rel > ==
		[	
			rel 1
			$rel
			<render entity $model $type.>	
			LocalPath:<>
		]	
		
	% <render rel $model ($type $rel) [ ... ]>
	% apply rel to current entity as Arg2 and specified entity as Arg1	
	<render relrev $model [ > == <render relrev2 $model <here $model type.> <here $model rel .> [ >
	<render relrev> == <render relrev2>
	<render relrev2 $model $type $rel > ==
		[	
			rel 2
			$rel
			LocalPath:<>
			<render entity $model $type.>
		]	

	% <render conj $model ($conjrel) [ ... ] [ ... ] >
	% use $conjrel to conjoin two instantiated arguments 
	<render conj $model [ > == <render conj2 $model <here $model conjrel .> [ >
	<render conj> == <render conj2>
	<render conj2 $model $conjrel> ==
		[
			rel 1
			$conjrel
			LocalPath:<>
		]
	
	% <render attr $model $attr>
	% add attribute annotation for attribute name $attr to current entity
	% if $attr is not an attribute, or has no value, do nothing
	<render attr $model **fail**> == LocalPath:<>
	<render attr> == <render attr2>
	<render attr2 $model $attr> == <render attr3 $model $attr <here $model $attr .> >
	<render attr3 $model $attr **fail**> == LocalPath:<>
	<render attr3> == <render attr4>
	<render attr4 $model $attr $val> ==
		[
			<render attr-type $attr>
			$attr $val
			LocalPath:<>
		]
		
	% <render extend $model [ ... ] >
	% return the semantics provided but with its span extended (leftwards) to include the current node
	<render extend $model [ entity $type $start> ==
		[ entity $type <here $model start-char> LocalPath:<>
	<render extend $model [ rel $f $rel > ==
		[ rel $f $rel <render extend $model>
	<render extend $model [ relrev $rel $f > ==
		[ relrev $f $rel <render extend $model>
	<render extend $model [ attr $attr $val > ==
		[ <render attr-type $attr> $attr $val <render extend $model>
	<render extend $model> == LocalPath:<>
	
	
	<render attr-type> == property
	% <render attr-type myattr> == attr % make myattr a BRAT attribute

	<process-attributes> ==
	<process-attributes params> == 
		<process-attribute params word>
		<process-attribute params form>
		<process-attribute params stem>
		<process-attribute params mform>
		<process-attribute params mtense>
		<process-attribute params mper>
		<process-attribute params mnum>
		<process-attribute params pos>
		<process-attribute params casetype>
		<process-attribute params soundex>
	<process-attributes $model 'Person'> ==
		<process-attribute $model gender .>
		<process-attribute $model title .>
		<process-attribute $model occupation .>
		<process-attribute $model age .>
		
	<process-attribute $model $feature> == <process-attribute2 <here $model $feature .> $feature <render attr-type $feature.> >
	<process-attribute2 $val $feature> == IF:< $val THEN $feature '==' $val .>
	<process-attribute2 $val $feature property> == IF:< $val THEN $feature '=' $val .>
	
	<process-annotation> ==
	% <process-annotation params> ==
		% <here params word>
		% <here params form>
		% <here params stem>
		% <here params mor form>
		% <here params mor tense>
		% <here params mor per>
		% <here params mor num>
		% <here params pos>
		% <here params casetype>
.



#hide nimrodel.ENDROOT.
nimrodel.ENDROOT:
    <> == nimrodel.LEX-TOP
    <all> ==
    <allprev> ==
    <allnext> ==
	
	<token pos> == endpoint
	<$model type> == **endpoint**
	<token start-char> == '?'
	<token end-char> == '?'
.

#hide nimrodel.LEXROOT.
nimrodel.LEXROOT:
    <> == nimrodel.LEX-TOP
	
	<$phrase> == <case <here lex cat .> $phrase>
	<sem> == <case <here lex cat .> sem>
	
	<case> == <case2>
	<case det> == nimrodel.phrase.DET:<>
	<case prep> == nimrodel.phrase.PREP:<>
	<case prepp> == nimrodel.phrase.PREPP:<>
	<case pro> == nimrodel.phrase.PRO:<>
	<case propn> == nimrodel.phrase.PROPN:<>
	<case n> == nimrodel.phrase.N:<>
	<case conj> == nimrodel.phrase.CONJ:<>
	<case adj> == nimrodel.phrase.ADJ:<>
	
	<case2 $any> == nimrodel.LEX-TOP:<>
	
	<all $model> == <allprev $model> <here> <allnext $model>
    <allprev $model> == <here $model prev allprev $model> <here $model prev>
    <allnext $model> == <here $model next> <here $model next allnext $model>
.



