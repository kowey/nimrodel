% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                                                           %
% File:            main.pl                                                  %
% Purpose:         top level driver predicate                               %
% Author:          Roger Evans and Liz Jenkins                              %
%                                                                           %
%      Copyright (c) University of Sussex 1992.  All rights reserved.       %
%                                                                           %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%   $Revision: 1.6 $
%   $Author: rpe $
%   $Date: 1997/11/23 21:03:34 $
%   $State: Exp $

%   -- datr_main(InFile,OutFile,CompileProc,Tag) ----------------------------
%
%   This predicate provides a standard top-level driver for the DATR
%   compilers.  It reads sentences from its input, and produces clauses
%   to be saved in its output. It handles the main control loop, different
%   compilation modes and declarations itself, but uses the specified
%   CompileProc to do actual compilation of DATR clauses.
%
%   InFile is the name of the input file (any structure acceptable to
%   'db_see'), from which characters are read and parsed, or a list of
%   ready-made parse trees.
%
%   OutFile is the name of the output file (any structure acceptable to
%   'db_tell') or one of the special files 'reconsult', 'consult', 'transient'
%   or return(X). If it is a file, the DATR input is compiled into a
%   free-standing prolog (source) program in that file. return(X) unifies the
%   clauses produced with X. The other modes add clauses to the prolog
%   database as follows:
%
%       reconsult - each node definition overwrites any existing one
%       consult   - each node definition augments any existing one
%       transient - each node definition augments any existing one, but
%                   only until the next query.
%
%   CompileProc is the NAME of a predicate which provides entry points
%   into the main compiler (for initialising, compiling, finalising etc.)
%   Tag is a tag identifying the compilation job - used to tag runtime
%   clauses generated by declarations


datr_main(InFile,OutFile,Proc,Tag) :- !,
    datr_call([Proc,init(C1)]),               % compiler initialise routine
    datr_reset_input(InFile,NewInFile,Tag),   % reset input stream
    datr_remove(transient),                   % clear out any transients...
    datr_remove(save),                        % ...and spurious saves
    db_retractall(datr_node_cleared(_)),      % reset cleared nodes
    datr_continue(NewInFile,OutFile,Proc,Tag). % start processing


%   get a sentence and process it

datr_continue(InFile,OutFile,Proc,Tag) :- !,
    datr_next_sentence(InFile,S,NewInFile),
    datr_main_loop(S,NewInFile,OutFile,Proc,Tag).


%   main loop: process a given sentence, then go for the next one

datr_main_loop(end_of_file, InFile, OutFile, Proc, Tag) :- !,
    %   do any end-of-compilation processing
    datr_end_main(OutFile,Proc,Tag).
datr_main_loop(dec(T,L),InFile,OutFile,Proc,Tag) :- !,
    %   handle declarations directly
    datr_declare(T,L,Clauses,Patt),         % build runtime code (if any)
    datr_add_runtime(OutFile,Tag,Clauses,Patt),  % add to output
    datr_continue(InFile,OutFile,Proc,Tag).
datr_main_loop(qquery(S),InFile,OutFile,Proc,Tag) :- !,
    %   sentence is a qquery - pass straight back to compiler
    datr_call([Proc, comp(qquery(S),_,_,_)]),           % compile
    datr_remove(transient),                             % remove ALL transients
    datr_continue(InFile,OutFile,Proc,Tag).
datr_main_loop(query(S),InFile,OutFile,Proc,Tag) :- !,
    %   sentence includes extensional statements (queries)
    datr_separate(S,Defs,Exts),                         % split defs and exts
    datr_call([Proc,comp(Defs,Clauses,CData,Node)]),    % compile defs
    datr_save_node(OutFile,Node,Proc,Tag),              % remember node
    datr_add_clauses(transient,Clauses,CData,Node),     % add as transient
    datr_call([Proc, comp(Exts,_,_,_)]),                % compile exts
    datr_remove(transient),                             % remove ALL transients
    datr_continue(InFile,OutFile,Proc,Tag).
datr_main_loop(S,InFile,OutFile,Proc,Tag) :- !,
    %   just definitional statements
    datr_call([Proc,comp(S,Clauses,CData,Node)]),       % compile defs
    datr_add_clauses(OutFile,Clauses,CData,Node),       % add to output
    datr_save_node(OutFile,Node,Proc,Tag),              % remember node
    datr_continue(InFile,OutFile,Proc,Tag).


%   end-of-compilation processing

datr_end_main(transient,Proc,_Tag) :- !,
    datr_remove(transient).
datr_end_main(reconsult,Proc,_Tag) :- !.
datr_end_main(consult,Proc,_Tag) :- !.
datr_end_main(return(Clauses),Proc,_Tag) :- !,
    datr_remove(save,X,Clauses).        % fetch saved clauses and return them
datr_end_main(OutFile,Proc,Tag) :- !,
    datr_remove(save,X,Clauses),                    % fetch saved clauses
    datr_call([Proc,final(Clauses,FinalClauses,Tag)]),  % finalise
    datr_save(FinalClauses,OutFile).                % write to file


%   split up ext and def statements

datr_separate([ext(N,P,V)|L],DL,[ext(N,P,V)|EL]) :- !,
    datr_separate(L,DL,EL).
datr_separate([def(N,P,V)|L],[def(N,P,V)|DL],EL) :- !,
    datr_separate(L,DL,EL).
datr_separate([],[],[]) :- !.


%   remember a node - construct a runtime clause for use for theorem dumps

datr_save_node(OutFile, Node, Proc, Tag) :-
    db_var(Node),!. % no node created
datr_save_node(OutFile, Node, Proc, Tag) :- !,
    datr_call([Proc,node(Node,Name)]),          % get nodename from ID
    datr_add_runtime(OutFile, Tag, [node(Name)], node(_)). % add runtime clauses

% optimise adding runtime clauses during (re)consult - otherwise adding all the
% node(_) statements is real performance hit on large files
% (really, all this stuff needs rewriting...)
datr_add_runtime(OutFile, Tag, Terms, Pattern) :- (OutFile=reconsult;OutFile=consult), !, datr_add_runtime_consult(Tag, Terms, Pattern).
datr_add_runtime(OutFile, Tag, Terms, Pattern) :-
    datr_map_runtime(Terms, RTerms,Tag),
    datr_map_runtime([Pattern], [RPattern], Tag),
    datr_add_clauses(OutFile, RTerms,[], RPattern).
	
datr_add_runtime_consult( _Tag, [], _Pattern) :- !.
datr_add_runtime_consult( Tag, [Term|Terms], Pattern) :- !,
    (datr_runtime(Tag, Term); db_assertz(datr_runtime(Tag, Term))), !,
    datr_add_runtime_consult( Tag, Terms, Pattern).	
	

datr_map_runtime([],[],_Tag).
datr_map_runtime([H|T], [datr_runtime(Tag, H)|RT], Tag) :-
    datr_map_runtime(T,RT,Tag).

%   adding clauses to current set

datr_add_clauses(_,[],_,_) :- !.
datr_add_clauses(reconsult,Clauses,CData,Node) :- !,
    datr_clear_real(Node),                  % ensure old def cleared out
    datr_remove(real,Node,RealClauses),     % fetch current real clauses
    datr_merge(Node,Clauses,CData,RealClauses,NewClauses), % merge new clauses
    datr_record(real,Node,NewClauses).      % add new def to database
datr_add_clauses(consult,Clauses,CData,Node) :- !,
    datr_record(consult,Node,Clauses),      % record asserted clauses
    datr_remove(real,Node,RealClauses),     % fetch current real clauses
    datr_merge(Node,Clauses,CData,RealClauses,NewClauses), % merge new clauses
    datr_record(real,Node,NewClauses).      % add new def to database
datr_add_clauses(transient,Clauses,CData,Node) :- !,
    datr_record(transient,Node,Clauses),    % record transient clauses
    datr_remove(real,Node,RealClauses),     % fetch current real clauses
    datr_merge(Node,Clauses,CData,RealClauses,NewClauses), % merge new clauses
    datr_record(real,Node,NewClauses).      % add new def to database
datr_add_clauses(OutFile,Clauses,CData,Node) :- !,
    datr_remove(save,Node,OldClauses),      % fetch clauses saved so far
    datr_merge(Node,Clauses,CData,OldClauses,NewClauses), % merge new clauses
    datr_record(save,Node,NewClauses).      % record new clauses for saving


%   -- input handling -------------------------------------------------------

%   Input is represented by a token which is assumed to change whenever
%   input is accessed. Thus resetting takes the given input token and returns
%   a new one (the 'reset input'), and reading etc. do likewise. For input
%   streams which are lists the alteration is obvious - read the head
%   and return the tail as next input token. For real devices we set
%   current input to the device and use the token to remember the
%   previous input device so we can restore it at the end.


%   resetting input

datr_reset_input(P,P,_Tag) :- (P=[_|_]; P=tokens(_)), !.    % parse trees need no resetting
datr_reset_input(InFile,state(Old,Type),Tag) :- !,
    db_seeing(Old),                     % save (and return) old input
    db_see(InFile),                     % make sure InFile is closed
    db_seen,
    datr_probe_file(InFile, Type),      % open the file to discover its content type
    db_retractall(datr_runtime(Tag, filetype(_))),
    db_asserta(datr_runtime(Tag,filetype(Type))),
    db_see(InFile, Type),               % reopen it appropriately for type
    datr_reset_sentence.                % reset the sentence reader


%   reading from input


datr_next_sentence([],end_of_file,[]) :- !. % end of a list of trees
datr_next_sentence([H|T],H,T) :- !.      % reading from a list of trees
datr_next_sentence(tokens(Tokens), Tree, tokens(Rest)) :- Tokens = [_|_], !,
	datr_sentence_from_tokens(Tokens, Rest, Sentence),
	datr_parse_tokens(Sentence, Tree).
datr_next_sentence(tokens([]), end_of_file, tokens([])) :- !.
datr_next_sentence(File,Tree,File) :-    % reading from a file
    File = state(Old, Type),
    datr_sentence(T, Type),!,            % got another sentence
	datr_parse_tokens(T, Tree), !.
datr_next_sentence(File,end_of_file,File) :- % end of real file
    % File contains OLD input source - restore it
    File = state(Old, Type),
    db_seen,
    db_see(Old).

datr_parse_tokens(Tokens, Tree) :-
	top_level(Tree,Tokens,[]), !.
datr_parse_tokens(Tokens, []) :-
	datr_warn(Tokens, 'unrecognised sentence').

%   -- Output handling ------------------------------------------------------

%   Write a list of clauses out to a file. Basically easy although we
%   don't handle very long lines specially so the file system has to cope

datr_save(Clauses,File) :- !,
    db_telling(Old),                        % remember old output stream
    db_tell(File),
    datr_write_clauses(Clauses),            % write out clauses
    db_told,
    db_tell(Old).                           % restore old stream


%   write clauses to a file

datr_write_clauses([]) :- !.
datr_write_clauses([H|T]) :- !,
    datr_write_clause(H), db_write(' .'), db_nl,
    datr_write_clauses(T).

%   writing a clause -- runtime clauses need to be asserted because
%   they may be spread across multiple files
datr_write_clause(X) :- functor(X,datr_runtime,2), !,
    db_write(':- '), db_writeq(assertz(X)).
datr_write_clause(X) :-
    db_writeq(X).

%   -- manipulating predicates ----------------------------------------------

%   clauses are viewed as of several types: 'real' (actually in
%   database), 'save' (stored to be saved in a file), 'consult' (added
%   in consult mode and 'transient' (added in transient mode). Clauses
%   of each type are recorded explicitly, except real which simply exist
%   in the database. These predicates add/remove and access these
%   clauses

datr_record(real,Node,Clauses) :- !,
    datr_assertlist(Clauses).
datr_record(Type, Node, Clauses) :- !,
    db_assertz(datr_recorded(Type,Node,Clauses)).

%   remove clauses and return them
datr_remove(real,Node,Clauses) :- !,
    datr_retracthead(Node,Clauses).
datr_remove(Type,Node,NewClauses) :-
    datr_copy(Node,TNode),
    db_retract(datr_recorded(Type,TNode,Clauses)), !,
    datr_retractlist(Clauses),
    datr_remove(Type,Node,IClauses),
    datr_append(Clauses,IClauses,NewClauses).
datr_remove(Type,Node,[]) :- !.

datr_remove(Type) :- !, datr_remove(Type,Node,Clauses).


%   Clear out any existing real definition (unless already done so
%   in this compilation run). Used by reconsult mode.

datr_clear_real(none) :- !.     % no new clauses were compiled
datr_clear_real(Node) :- datr_node_cleared(Node), !.
datr_clear_real(Node) :- !,
    datr_remove(real,Node,Clauses),
    db_assertz(datr_node_cleared(Node)).


%   (dynamic) predicates for remembering info about clauses

:- db_asserta((datr_recorded(_,_,_) :- fail)).
:- db_asserta((datr_node_cleared(_) :- fail)).


%   -- merging clauses ------------------------------------------------------

%   When we add new clauses to a node definition we have to order them
%   to make the default strategy work (paths which extend other defined
%   paths must precede them in the predicate def)

datr_merge(datr_runtime(F,X),Clauses,CData,Old,New) :- !,
    % runtime bookkeeping clauses - just check for duplication
    datr_union(Old,Clauses,New).
datr_merge(Node,Clauses,CData,Old,New) :- !,
    datr_do_merge(Clauses,CData,Old,New).

datr_do_merge([],[],New,New) :- !.
datr_do_merge([Clause|Clauses],[CD|CData],Old,New) :- !,
    Clause = (Head :- Tail),
    datr_merge_one(Old,Head,Clause,CD,Temp),
    datr_do_merge(Clauses,CData,Temp,New).

datr_merge_one([],Head,Clause,CD,[Clause]) :- !.
datr_merge_one(OldL,Head,Clause,X,[Clause|OldL]) :-
    %   fetch head of old clause
    OldL = [(Head2 :- Tail2) | _],
    %   freeze end of list in head and test for extension
    db_not(db_not((X=not_a_list, datr_precedes(Head,Head2)))),!.
datr_merge_one([Old|OldL],Head,Clause,CD,[Old|New]) :- !,
    datr_merge_one(OldL,Head,Clause,CD,New).

% if heads unify then Head1 precedes Head2 (because Head1 is frozen)
datr_precedes(Head1, Head2) :- Head1=Head2, !.
% if heads don't unify, check whether P1 is longer than P2
datr_precedes(Head1, Head2) :-
    arg(1,Head1,P1),
    arg(1,Head2,P2),
    datr_precedes2(P1,P2).

datr_precedes2([_|_], []) :- !.
datr_precedes2([_|P1], [_|P2]) :- datr_precedes2(P1, P2).
